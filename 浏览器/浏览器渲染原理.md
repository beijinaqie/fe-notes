[toc]

https://segmentfault.com/a/1190000012925872

 一文看懂Chrome浏览器运行机制https://zhuanlan.zhihu.com/p/102149546

# **一**、进程vs 线程

类比

- 进程是一个工厂，工厂有它的独立资源
- 工厂之间相互独立
- 线程是工厂中的工人，多个工人协作完成任务
- 工厂内有一个或多个工人
- 工人之间共享空间

完善概念

- 工厂的资源 -> 系统分配的内存（独立的一块内存）
- 工厂之间的相互独立 -> 进程之间相互独立
- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务
- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成
- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）

如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。

![window进程](https://segmentfault.com/img/remote/1460000012925877)

所以，应该更容易理解了：**进程是cpu资源分配的最小单位（系统会给它分配内存）**

最后，再用较为官方的术语描述一遍：

- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

**tips**

- 不同进程之间也可以通信，不过代价较大
- 现在，一般通用的叫法：**单线程与多线程**，都是指**在一个进程内**的单和多。（所以核心还是得属于一个进程才行）

# 二、多进程的浏览器

理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）

- 浏览器是多进程的
- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。

![浏览器进程](https://segmentfault.com/img/remote/1460000012925878)

知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）

1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有
   - 负责浏览器界面显示，与用户交互。如前进，后退等
   - 负责各个页面的管理，创建和销毁其他进程
   - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
   - 网络资源的管理，下载等
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU进程：最多一个，用于3D绘制等
4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为
   - 页面渲染，脚本执行，事件处理等

强化记忆：**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**

![](https://segmentfault.com/img/remote/1460000012925879)

相比于单进程浏览器，多进程有如下优点：

- 避免单个page crash影响整个浏览器
- 避免第三方插件crash影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

简单点理解：**如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。**

**请牢记，浏览器的渲染进程是多线程的**

1. GUI渲染线程
   - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
   - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
2. JS引擎线程
   - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
   - JS引擎线程负责解析Javascript脚本，运行代码。
   - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
   - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
3. 事件触发线程
   - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
   - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
   - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
4. 定时触发器线程
   - 传说中的`setInterval`与`setTimeout`所在线程
   - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
   - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. 异步http请求线程
   - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。

浏览器内核

![浏览器内核](https://segmentfault.com/img/remote/1460000012925880)

**浏览器的Browser进程（控制进程）是如何和内核通信**

如果自己打开任务管理器，然后打开一个浏览器，就可以看到：**任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）**，
然后在这前提下，看下整个的过程：(简化了很多)

- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
  - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
  - 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
  - 最后Render进程将结果传递给Browser进程
- Browser进程接收到结果并将结果绘制出来

![](https://segmentfault.com/img/remote/1460000012925881)

# 三、浏览器渲染流程

- 浏览器输入url，浏览器主进程接管，开一个下载线程，
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始

浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

1. 解析html建立dom树
2. 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

这里说的是头部引入css的情况

首先，我们都知道：**css是由单独的下载线程异步下载的。**

然后再说下几个现象：

- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

这可能也是浏览器的一种优化机制。

因为你加载css的时候，可能会修改下面DOM节点的样式，
如果css加载不阻塞render树渲染的话，那么当css加载完之后，
render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。
所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，
在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。

一帧浏览器要做的事

更新渲染过程
1. 遍历当前浏览上下文中所有的 document，必须按在列表中找到的顺序处理每个 document。
2. 渲染时机 (Rendering opportunities)：如果当前浏览上下文中没有到渲染时机则将所有 docs 删除，
取消渲染（此处是 否存在渲染时机由浏览器自行判断，根据硬件刷新率限制、页面性能或页面是否在
后台等因素）。
3. 如果当前文档不为空，设置 hasARenderingOpportunity 为 true。
4.不必要的渲染 (Unnecessary rendering) 如果浏览器认为更新文档的浏览上下文的呈现不会产生可
见效果且文档的 animation frame callbacks 是空的，则取消渲染。（终于看见
requestAnimationFrame 的身影了
5. 从 docs 中删除浏览器认为出于其他原因最好跳过更新渲染的文档。
6.如果文档的浏览上下文是顶级浏览上下文，则刷新该文档的自动对焦候选对象。
7. 处理 resize 事件，传入一个 performance.now() 时间戳。
8. 处理 scroll 事件，传入一个 performance.now() 时间戳。
9. 处理媒体查询，传入一个 performance.now() 时间戳。
10. 运行 CSS 动画，传入一个 performance.now() 时间戳。
11. 处理全屏事件，传入一个 performance.now() 时间戳。
12. 执行 requestAnimationFrame 回调，传入一个 performance.now(） 时间戳。
13. 执行 intersectionObserver 回调，传入一个 performance.now() 时间戳。
14. 对每个 document 进行绘制。
15. 更新 ui并呈现。

![](https://img12.360buyimg.com/img/s1354x438_jfs/t1/132190/38/20327/148065/5fd9f770Ec5d5e18b/9f86c81e18fd5bc4.png)

- 处理用户的交互
- JS 解析执行
- 帧开始。窗口尺寸变更，页面滚去等的处理
- requestAnimationFrame(rAF)
- 布局
- 绘制

http://www.zhufengpeixun.com/strong/html/146.browser.html#t233.4%20%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%E6%A0%91

渲染进程(https://juejin.cn/post/6844903506059477000#heading-8)

#### 进程

blink和webkit引擎内部都是使用了两个进程来搞定JS执行、页面渲染之类的核心任务。

- Renderer进程
  主要的那个进程，每个tab一个。负责执行JS和页面渲染。包含3个线程：Compositor Thread、Tile Worker、Main thread，后文会介绍这三个线程。
- GPU进程
   整个浏览器共用一个。主要是负责把Renderer进程中绘制好的tile位图作为纹理上传至GPU，并调用GPU的相关方法把纹理draw到屏幕上（一般的介绍浏览器渲染引擎的文章里都用paint这个词表述把内容光栅化和绘制到位图里，而用draw这个词表示GPU最终把纹理显示到屏幕上），所以这个CPU里的进程更应该称为“负责跟GPU打交道的进程”，不要像我之前一样因为不懂GPU以为是GPU里的一个进程, mdzz。GPU进程里只有一个线程：GPU Thread。

#### Renderer进程的三个线程

- Compositor Thread
   这个线程既负责接收浏览器传来的垂直同步信号(Vsync，水平同步表示画出一行屏幕线，垂直同步就表示从屏幕顶部到底部的绘制已经完成，指示着前一帧的结束，和新一帧的开始)， 也负责接收OS传来的用户交互，比如滚动、输入、点击、鼠标移动等等。
   如果可能，Compositor Thread会直接负责处理这些输入，然后转换为对layer的位移和处理，并将新的帧直接commit到GPU Thread，从而直接输出新的页面。否则，比如你在滚动、输入事件等等上注册了回调，又或者当前页面中有动画等情况，那么这个时候Compositor                Thread便会唤醒Main Thread，让后者去执行JS、完成重绘、重排等过程，产出新的纹理，然后Compositor Thread再进行相关纹理的commit至GPU Thread，完成输出。
- Main Thread
  ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/e0b1c8fb05bc487e204d8efa57fdd80b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
  这里大家就很熟悉了，chrome devtools的Timeline里Main那一栏显示的内容就是Main Thread完成的相关任务：某段JS的执行、Recalculate                Style、Update Layer Tree、Paint、Composite Layers等等。 
- Compositor Tile Worker(s)
   可能有一个或多个线程，比如PC端的chrome是2个或4个，安卓和safari为1个或2个不等。是由Compositor Thread创建的，专门用来处理tile的Rasterization（前文说过的光栅化）。

可以看到Compositor Thread是一个很核心的东西，后面的俩线程都是由他主要进行控制的。
同时，用户输入是直接进入Compositor Thread的，一方面在那些不需要执行JS或者没有CSS动画、不重绘等的场景时，可以直接对用户输入进行处理和响应，而Main Thread是有很复杂的任务流程的。这使得浏览器可以快速响应用户的滚动、打字等等输入，完全不用进主线程。这里也有一个非常重要的点，后文会说。
再者，即使你注册了UI交互的回调，进了主线程，或者主线程很卡，但是因为Compositor            Thread在他外面拦着，所以Compositor Thread依然可以直接负责将下一帧输出到页面上，因此即使你的主线程可能执行着高耗任务，超过16ms，但是你在滚动页面时浏览器还是能做出响应的（同步AJAX等特殊任务除外），所以比如你有一个比较卡的动画（动画的预先计算过程或者重绘过程超过16ms每帧），但是你滚动页面是非常流畅的，也就是动画卡而滚动不卡([随便给你个demo自己试试看](https://link.juejin.cn?target=http%3A%2F%2Fcodepen.io%2FSitePoint%2Fpen%2FWQVxQQ%2F))。

### 具体流程

一般我们在devtools的Timeline里大概会看到如下过程:
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/7af56bc1169696a1f8307af240888c01~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
也就是JS执行后触发重绘重排等操作。这里着重分析背后的运行过程，即下面这副图：
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/0925cf2247c6e43ce867d41c6c25d8ce~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
图里后半部分有两处commit，分别是主线程通知Main Thread可以执行光栅化了，以及光栅化完成、纹理生成完毕，Compositor Thread通知GPU Thread可以将纹理按照指定的参数draw到屏幕上。

#### 整体流程：

1. Vsync
   接收到Vsync信号，这一帧开始

2. Input event handlers之前Compositor Thread接收到的用户UI交互输入在这一刻会被传入给主线程，触发相关event的回调。

   > All input event handlers (touchmove, scroll, click) should fire first, once per frame, but that’s not necessarily the case; a scheduler makes best-effort attempts, the success of which varies between Operating Systems. 

   这意味着，尽管Compositor Thread能在16ms内接收到OS传来的多次输入，但是触发相应事件、传入到主线程被JS感知却是每帧一次，甚至可能低于每帧一次。也就是说touchmove、mousemove等事件最快也就每帧执行一次，所以自带了相对于动画的节流效果！如果你的主线程有动画之类的卡了一点，事件触发频率非常可能低于16ms。我在最开始关于渲染时机的内容中说了scroll和resize因为和渲染处于同一轮次，所以最快也就每帧执行一次，**现在来看，不仅仅是scroll和resize！连touchmove、mousemove等事件，由于Compositor Thread的机制原因，也依然如此**！
                       [详见这个jsfiddle](https://link.juejin.cn?target=https%3A%2F%2Fjsfiddle.net%2Fstqk5dpz%2F)，大家可以试试，你可以发现mousemove回调和requestAnimationFrame回调的调用频率是完全一致的，mousemove的执行次数跟raf执行次数一模一样，**永远**没有任何一次出现mousemove执行两次而rAF还没有执行一次的情况发生。另外两次执行间隔在14到20毫秒之间，主要是因为帧的间隔不会精确到16.666毫秒哈，基本是14ms~20ms之间大致波动的，大家可以打开timeline观察。*另外有个挺奇怪的现象是每次鼠标从devtool移回页面区域里的时候，会非常快的触发两次mousemove（间隔有时小于5ms），虽然依然每次mousemove后依然紧跟raf，这意味着非常快速的触发了两帧。*

3. requestAnimationFrame
   图中的红线的意思是你可能会在JS里[Force Layout](https://link.juejin.cn?target=http%3A%2F%2Fgent.ilcore.com%2F2011%2F03%2Fhow-not-to-trigger-layout-in-webkit.html)，也就是我们说的访问了scrollWidth、clientHeight、ComputedStyle等触发了强制重排，导致Recalc Styles和Layout前移到代码执行过程当中。

4. parse HTML
   如果有DOM变动，那么会有解析DOM的这一过程。

5. Recalc Styles
   如果你在JS执行过程中修改了样式或者改动了DOM，那么便会执行这一步，重新计算指定元素及其子元素的样式。

6. Layout
   我们常说的重排reflow。如果有涉及元素位置信息的DOM改动或者样式改动，那么浏览器会重新计算所有元素的位置、尺寸信息。而单纯修改color、background等等则不会触发重排。详见[css-triggers](https://link.juejin.cn?target=https%3A%2F%2Fcsstriggers.com%2F)。

7. update layer tree
   这一步实际是更新Render Layer的层叠排序关系，也就是我们之前说的为了搞定层叠上下文搞出的那个东西，因为之前更新了相关样式信息和重排，所以层叠情况也可能变动。

8. Paint其实Paint有两步，第一步是记录要执行哪些绘画调用，第二步才是执行这些绘画调用。第一步只是把所需要进行的操作记录序列化进一个叫做SkPicture的数据结构里:

   > The SkPicture is a serializable data structure that can capture and then later replay commands, similar to a [display list](https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDisplay_list).

   这个SkPicture其实就一个列表，记录了你的commands。接下来的第二步里会将SkPicture中的操作replay出来，这里才是将这些操作真正执行：光栅化和填充进位图。主线程中和我们在Timeline中看到的这个Paint其实是Paint的第一步操作。第二步是后续的Rasterize步骤（见后文）。

9. Composite
   主线程里的这一步会计算出每个Graphics Layers的合成时所需要的data，包括位移（Translation）、缩放（Scale）、旋转（Rotation）、Alpha 混合等操作的参数，并把这些内容传给Compositor Thread，然后就是图中我们看到的第一个commit：Main Thread告诉Compositor Thread，我搞定了，你接手吧。然后主线程此时会去执行requestIdleCallback。这一步并没有真正对Graphics                Layers完成位图的composite。

10. Raster Scheduled and Rasterize第8步生成的SkPicture records在这个阶段被执行。

    > SkPicture records on the compositor thread get turned into bitmaps on the GPU in one of two ways: either painted by Skia’s software rasterizer into a bitmap and uploaded to the GPU as a texture, or painted by Skia’s OpenGL backend                        (Ganesh) directly into textures on the GPU.

    可以看出Rasterization其实有两种形式：

    - 一种是基于CPU、使用Skia库的Software Rasterization，首先绘制进位图里，然后再作为纹理上传至GPU。这一方式中，Compositor Thread会spawn出一个或多个Compositor Tile Worker Thread，然后多线程并行执行SkPicture records中的绘画操作，以之前介绍的Graphics Layer为单位，绘制Graphics Layer里的Render Object。同时这一过程是将Layer拆分为多个小tile进行光栅化后写入进tile对应的位图中的。
    - 另一种则是基于GPU的Hardware Rasterization，也是基于Compositor Tile Worker Thread，也是分tile进行，但是这个过程不是像Software Rasterization那样在CPU里绘制到位图里，然后再上传到GPU中作为纹理。而是借助Skia’s OpenGL backend (Ganesh) 直接在GPU中的纹理中进行绘画和光栅化，填充像素。也就是我们常说的GPU Raster。

    现在基本最新版的几大浏览器都是硬件Rasterization了，但是对于一些移动端基本还是Software Rasterization较多。打开你的chrome浏览器输入[chrome://gpu/](https://link.juejin.cn?target=undefined) 可以看看你的chrome的GPU加速情况。下图是我的：
    ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/c3ffb73ac0a5dcd0468d37095b1d4652~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
    使用Hardware Rasterization的好处在于：以往Software Rasterization的方式，受限于CPU和GPU之前的上传带宽，把位图从RAM里上传到GPU的VRAM里的过程是有不可忽视的性能开销的。若Rasterization的区域较大，那么使用Software Rasterization很可能在这里出现卡顿。下面这个例子是Chrome32和Chrome41的对比，后者的版本实现了Hardware                    Rasterization。
     
    不过，对于图片、canvas等情况，我没有查到到底是怎么处理的，但是我觉得绝对是有一个从CPU上传到GPU的过程的，所以应该有一些情况不是纯Hardware Rasterization的，两者应该是结合使用的。另外就是硬件还是软件Rasterization主要还是由设备决定的，在这个地方并没有我们手动优化的空间，但是这里涉及到一些后面的内容，所以简单介绍了一下。

11. commit
    如果是Software Rasterization，所有tile的光栅化完成后Compositor Thread会commit通知GPU Thread，于是所有的tile的位图都会作为纹理都会被GPU Thread上传到GPU里。如果是使用GPU 的Hardware Rasterization，那么此时纹理都已经在GPU中。接下来，GPU Thread会调用平台对应的3D API(windows下是[D3D](https://link.juejin.cn?target=http%3A%2F%2Fbaike.baidu.com%2Flink%3Furl%3DiukraGeY0dHYga0DQD-SbwQ9az37FcXwzhd0j_cFsGTEiKjOa8Q74T9i-I11webzQ1HtjjVDq_zYugxMDsuRUa)，其他平台都是GL)，把所有纹理绘制到最终的一个位图里，从而完成纹理的合并。
                        同时，非常关键的一点：在纹理的合并时，借助于3D API的相关合成参数，可以在合并前对纹理transformations（也就是之前提到的位移、旋转、缩放、alpha通道改变等等操作），先变形再合并。合并完成之后就可以将内容呈现到屏幕上了。

并不是每次渲染都会执行上述11步的所有步骤，比如Layout、Paint、Rasterize、commit可能一次都没有，但是Layout又可能会不止一次。另外还有利用合成层提升来获得GPU加速的动画等相关技术的原理。接下里就是对上述步骤更加详细的分析。

### 重排 Layout、强制重排 Force Layout

重排和强制重排是老生常谈的东西了，大家也应该非常熟悉了，但在这里可以结合浏览器机制顺带讲一遍。

首先，如果你改了一个影响元素布局信息的CSS样式，比如width、height、left、top等（transform除外），那么**浏览器会将当前的Layout标记为dirty**，这会使得浏览器在**下一帧**执行上述11个步骤的时候执行Layout。因为元素的位置信息变了，将可能会导致整个网页其他元素的位置情况都发生改变，所以需要执行Layout全局重新计算每个元素的位置。

需要注意到，浏览器是在下一帧、下一次渲染的时候才重排。并不是JS执行完这一行改变样式的语句之后立即重排，所以你可以在JS语句里写100行改CSS的语句，但是只会在下一帧的时候重排一次。

**如果你在当前Layout被标记为dirty的情况下，访问了offsetTop、scrollHeight等属性，那么，浏览器会立即重新Layout，计算出此时元素正确的位置信息，以保证你在JS里获取到的offsetTop、scrollHeight等是正确的。**

*会触发重排的属性和方法:*
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/4f3a5985cba7a760c12292a173a132e7~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

这一过程被称为强制重排 Force Layout，这一过程强制浏览器将本来在上述渲染流程中才执行的Layout过程**前提**至JS执行过程中。前提不是问题，问题在于每次你在Layout为dirty时访问会触发重排的属性，都会Force Layout，这极大的延缓了JS的执行效率。

```
//Layout未dirty 访问domA.offsetWidth不会Force Layout
domA.style.width = (domA.offsetWidth + 1) + 'px' 
//Layout已经dirty， Force Layout
domB.style.width = (domB.offsetWidth + 1) + 'px' 
//Layout已经dirty， Force Layout
domC.style.width = (domC.offsetWidth + 1) + 'px'
复制代码
```

这三行代码的后两行都导致了Force Layout，Layout一次的时间视DOM数量级从几十微秒到十几毫秒不等，相比于一行JS 1微秒不到的执行时间，这个开销是难以接受的。所以也就有了读写分离、纯用变量存储等避免Force Layout的方法。否则你就会在你Timeline里看到这种10多次Recalculate Style 和 Layout的画面了。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/219f94aa4eb7ca789bf18b5e90e70148~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

另外，**每次重排或者强制重排后，当前Layout就不再dirty**。所以你再访问offsetWidth之类的属性，并不会再触发重排。

```
// Layout未dirty 访问多少次都不会触发重排
console.log(domA.offsetWidth) 
console.log(domB.offsetWidth) 

//Layout未dirty 访问domA.offsetWidth不会Force Layout
domA.style.width = (domA.offsetWidth + 1) + 'px' 
//Layout已经dirty， Force Layout
console.log(domC.offsetWidth) 

//Layout不再dirty，不会触发重排
console.log(domA.offsetWidth) 
//Layout不再dirty，不会触发重排
console.log(domB.offsetWidth)
复制代码
```

### 重绘 Paint

重绘也是相似的，一旦你更改了某个元素的会触发重绘的样式，那么浏览器就会在下一帧的渲染步骤中进行重绘。也即一些介绍重绘机制中说的invalidating(作废)，JS更改样式导致某一片区域的样式作废，从而在一下帧中重绘invalidating的区域。

但是，有一个非常关键的行为，就是：**重绘是以合成层为单位的**。也即 **invalidating的既不是整个文档，也不是单个元素，而是这个元素所在的合成层**。当然，这也是将渲染过程拆分为Paint和Compositing的初衷之一：

> Since painting of the layers is decoupled from compositing, invalidating one of these layers only results in repainting the contents of that layer alone and recompositing.

这里给出两个demo: [demo1](https://link.juejin.cn?target=http%3A%2F%2Fchuckliu.me%2Fdemo%2Fbrowser-rendering-process%2Fpainting-with-compositing-layer.html) 和 [demo2](https://link.juejin.cn?target=http%3A%2F%2Fchuckliu.me%2Fdemo%2Fbrowser-rendering-process%2Fpainting-without-compositing-layer.html)

两个demo几乎完全一样，除了第二demo的.ab-right的样式里多了一行，`will-change:transform;`。*我们在前文介绍合成层的时候强调过`will-change: transform`会让元素强制提升为合成层。*

```
.ab-right {
        will-change: transform; //多了这行
        position: absolute;
        right: 0;
}
复制代码
```

于是在第二个demo中出现了两个合成层：HTML根元素的合成层和.ab-right所在的合成层。

然后我们在js中修改了#target元素的样式，于是#target元素在的合成层(即HTML根元素的合成层)被重绘。在demo1中，.ab-right元素没有被提升为合成层，于是.ab-right也被重绘了。而在demo2中，.ab-right元素并没有重绘。先看demo1:

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/75711061e888019d0709ee6b70908fcd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
明显的看到.ab-right被重绘了。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/066590987a44763dd9f9f9f7a4382163~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
显然，demo2只重绘了HTML根元素的合成层的内容。

对了，你还可以顺便点到Raster一栏去看看Rasterization的具体过程。前面已经介绍过了，这里真正完成Paint里的操作，将内容绘制进位图或纹理中，且是分tile进行的。
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/e53e4ab8b09a59cd9d366b7e8cdc67f4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 重排和重绘和Compositing

先说点题外的，怎么查看合成层:

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/8dc0cb8bdf03cf621411dbf3cae98b43~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

修改一些CSS属性如width、float、border、position、font-size、text-align、overflow-y等等会触发重排、重绘和合成，修改另一些属性如color、background-color、visibility、text-decoration等等则不会触发重排，只会重绘和合成，具体属性列表请自行google。

接下来很多文章里就会说，**修改opacity、transform这两个属性仅仅会触发合成，不会触发重绘和合成。**所以一定要用这两个属性来实现动画，没有重绘重排，效率很高。

**然而事实并不是这样。**

**只有一个元素在被提升为合成层之后，上述情况才成立。**

回到我们之前说的渲染过程的第11步:

> 同时，非常关键的一点：在纹理的合并时，借助于3D API的相关合成参数，可以在合并前对纹理transformations（也就是之前提到的位移、旋转、缩放、alpha通道改变等等操作），先变形再合并。合并完成之后就可以将内容呈现到屏幕上了。

在合成多个合成层时，确实可以借助3D API的相关参数，从而直接实现合成层的transform、opacity效果。所以如果你将一个元素提升为合成层，然后用JS修改其transform或opacity 或者在 transform或opacity 上施加CSS过渡或动画，确实会避免CPU的Paint过程，因为transform和opacity可以直接基于GPU的合成参数来完成。

但是，这是在合成层整体有transform或opacity才会这么做。对于没有提升为合成层的元素，仅仅是他自己具有transform和opacity，他是作为合成层的内容。而生成合成层的内容和写进位图或纹理是在Paint和Rasterize阶段完成的，因此这个元素的transform和opacity的实现也是在Paint和Rasterize中完成的。所以还是会重排，也就没有启用我们常说的GPU加速的动画。

比如[这个demo](https://link.juejin.cn?target=http%3A%2F%2Fchuckliu.me%2Fdemo%2Fbrowser-rendering-process%2Fchange-transform.html)，一个提升为合成层的div#father和一个未提升合成层的div#child，3秒钟后JS更改child和father的transform属性。 接下来渲染的时候流程是怎样的？

1. Recalc Styles(重新计算样式) 
2. Paint 绘制变动的合成层 即 div#father                
   1. Paint 绘制父元素的背景和textNode(即”父元素 提升为合成层”)
   2. Paint 绘制child元素 即div#child                        
      1. Paint 先translate，完成移动
      2. Paint 再在移动后的区域里绘制子元素的背景和textNode(即”子元素 未提升为合成层”)
3. Rasterize 
4. Composite 合并合成层，在合成时借助于3D API的相关合成参数完成合成层的位移、旋转等变换，所以div#father的translate在这里实现

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/be6b470a2bdc267cd265915b9cbcd76a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

所以我们看到了，对于未提升合成层的元素，他的transform、opacity等是在主线程里Paint和配合Rasterize来实现的（其他的需要重绘的属性更是如此），依然会触发重绘，直接用JS改动这俩属性并不会获得性能提升。而如果元素已提升为合成层，那么他的transform、opacity等样式的实现就是直接由GPU Thread控制在GPU中Compositing来完成的，主线程的Composite步骤只是计算出合成的参数，耗时极小，速度极快，所以因此就有了尽量使用transform和opacity来完成动画的经验之谈。

借用[这篇文章中的例子](https://link.juejin.cn?target=http%3A%2F%2Fblogs.adobe.com%2Fwebplatform%2F2014%2F03%2F18%2Fcss-animations-and-transitions-performance%2F):

```
div {
    height: 100px;
    transition: height 1s linear;
}

div:hover {
    height: 200px;
}
复制代码
```

这段transition的实现过程是这样的:
![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/01a03767148f0b9de883d4c001c4599c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

而如果代码变成了这样

```
div {
    transform: scale(0.5);
    transition: transform 1s linear;
}

div:hover {
    transform: scale(1.0);
}
复制代码
```

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/0c84f68d906fede8a1dd0e14201c0827~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)
也就是Main Thread不用重排，不用重绘，Draw也不是他完成的，他的Composite步骤只是计算出具体的Compositing参数而已（示例中其实右边应该是Compositor和GPU Thread，但是作者为了简化概念、便于阐述，直接就没有提GPU            Thread，大家不要在此处扣细节）。

另外，第二个例子中div为什么提升为合成层，其实就是前文介绍合成层的时候说的：

> 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）

括号中的内容也很关键，元素在opacity等属性具有动画时，并不是直接就提升为合成层，而是动画或者transition开始时才提升为合成层，并且结束后提升合成层也失效。
同时，元素在提升为合成层或者提升合成层失效时，会触发重绘。这也是上图一开始在动画开始前有`Layout the element first time` 和`Paint the element into the bitmap`两步的原因：transition开始前，div并未被提升为合成层，transition开始，div立马提升合成层，立马导致其本来所在的合成层重绘（因为要剔除掉提升为合成层的div），并且div因为提升为合成层，也立马重绘，两个重绘好的合成层Rasterize后上传至GPU中。

[demo在此](https://link.juejin.cn?target=http%3A%2F%2Fchuckliu.me%2Fdemo%2Fbrowser-rendering-process%2Fpaint-before-and-after-transition.html)，所以在动画开始前看到：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/359aa3b9301313cfc21eb5f6ff223044~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

在动画结束后的那一帧则是这样:

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/048cc092914a1a5d846973d50cf693f8~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

这个上述demo中，只有2个dom，所以Paint开销几乎可以忽略，但是如果是dom数量多一些，那么就很可能是下面这样了。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/25/6abbc39d386eae2476f2c1a70acb17f4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

实时上这个情况不止是在动画和过渡时，只要一个元素被提升为合成层，在提升前和合成层失效时都会有这个过程，所以一方面是重绘带来了绘制开销，另外则是纹理上传过程因为CPU到GPU的带宽带来的上传开销（虽然现在已经有Hardware Raster不用上传，但是仍然有不能用Hardware Raster的情况，而且Hardware Raster绘制进纹理的绘制过程本身也是有开销的）。 因此处理不好就可能导致动画开始前和开始后出现一帧卡顿/延迟。

最后，重要的一点，也是一般谈到性能优化的文章中都会介绍的一点，即：

> **合成层提升并非银弹。**

合成层提升一方面可能会引入纹理生成、上传和重绘的开销，而且合成层提升后会占用GPU VRAM，VRAM可并不会很大。对于移动端，上述两个问题尤甚。而且在介绍合成层时，我还介绍了合成层存在隐式提升的情况。因此请合理使用。

本文主要介绍原理，所以怎么去实现16ms的动画、怎么去提升渲染性能、怎么去优化合成层数量和避免层爆炸等等、以及到底哪些情况会提升合成层、触发重绘等详细内容还是见文末附录吧。

## 总结

正文算是比较详细的介绍浏览器的渲染过程，可能需要你事先理解重绘、重排和合成，结合了一些demo，深入了一些我之前理解错的点。

这里再次强调一下一些颠覆了我认知的内容：

- 按照HTML5标准，scroll事件是每帧触发一次的，自带requestAnimationFrame节流效果
- 按照Blink和Webkit引擎实现，touchmove、mousemove等UI input由Compositor线程接收，但传入到主线程是每帧一次，也自带requestAnimationFrame节流效果
- 重绘是以合成层为单位的
- 合成层提升前后的Paint步骤


作者：SunGuoQiang123
链接：https://juejin.cn/post/6844903506059477000
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 四、Event Loop

渲染器进程要处理 DOM、计算样式、处理布局渲染，同时协调事件，用户交互，脚本，联网个过程使用到了event loop（事件循环）。我们需要简单了解event loop。

了解event loop 需要了解几个问题：

- FPS
- 堆，调用栈等概念
- 执行顺序

## 2.1 FPS

### 2.1.1 帧，FPS（每秒传输帧数）

> **帧**：就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头

> **FPS**是图像领域中的定义，是指画面每秒传输[帧数](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%B8%A7%E6%95%B0%2F8019296)，通俗来讲就是指动画或视频的画面数。

当页面的帧率下降，即每秒刷新屏幕的次数降低时（眼睛可察觉范围），就会感觉屏幕上显示内容抖动或卡顿。

### 2.1.2 页面如何看起来顺畅了？

显示器以固定频率进行刷新通常是 60HZ（此处以通用频率举例），即每秒更新60次图像，设备每秒刷新屏幕60(FPS)次（这个帧率适合人眼交互）。

当前正在运行动画或过渡，或者用户正在滚动页面，则浏览器需要匹配设备的刷新率，并为每个屏幕刷新放置1张新图片或一帧，以实现平滑动画。这些帧中的每个帧的预算都刚刚超过16毫秒（1秒/ 60 = 16.66毫秒），页面看起来就是顺畅的。

### 2.1.3 怎么页面查看FPS？

在控制台分析页面性能查看FPS，[performance 工具的使用](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fchrome-devtools%2Fevaluate-performance)

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b7a1c7da948464a91a18d7ddb253712~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)可以看到当前的FPS，以及当前帧的信息。此处的帧信息是浏览器的，不是屏幕的。

### 2.1.4页面渲染中我们可控的关键流程

像素管道一般由 5 个部分组成，JavaScript、样式、布局、绘制、合成，如下图所示:

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/119024e917044821b25de8fd2d8f17fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)**[图片源](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Frendering)**

前面介绍了**Style calculation，Layout，Paint ，compositie
 **关于JavaScript 对页面渲染的关联：我们可以使用 JavaScript 来实现一些视觉变化的效果，但需合理使用。

### 2.1.5 卡顿掉帧

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df47e9f8c5c4c6a9168d6dc0819d4bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

时间间隔假设是屏幕固有更新频率。

通常使用setTimeout或setInterval进行视觉更改（例如动画），会造成问题，因为回调将在屏幕帧中的某个点（可能恰好在结尾处）运行，并且通常会导致我们错过了一个帧，从而产生了卡顿，掉帧。

这也是requestAnimationFram 解决的问题， requestAnimationFrame callback 在 render 阶段执行即浏览器下次重绘之前调用指定的requestAnimationFrame callback回调函数，以确保代码会在重绘之前执行。

## 2.2 堆(Heap)，调用栈(call stack)等概念

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d975d8247f4591bf53c6f09faf8347~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

**堆（Heap）:** 对象是在堆中分配的，堆只是一个名称，表示一个大的（主要是非结构化的）内存区域。

**调用栈（Callback Stack）：**调用栈是一个栈结构，在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。这种用来管理执行上下文的栈称为调用栈。

**Tasks queue (Macrotask queue)：**任务队列是集合，而不是队列，因为事件循环处理模型的第一步从选定的队列中获取第一个可运行任务，而不是使第一个任务出队。

Task(Macrotask)：包含执行整体的js代码script，事件回调，XHR回调，定时器（setTimeout/setInterval），I/O操作

**Microtask：**包括promise回调，MutationObserver

## 2.3 event loop 执行顺序

### 2.3.1 简述规范

**[事件循环模型规范](https://link.juejin.cn?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23event-loop-processing-model)**

简述：

- 从 task 队列（ 一个或多个） 中选出最旧的一个 task， 执行它。
- 执行 microtask 队列中的所有 microtask， 直到队列为空。如果 microtask 中又添加了新的 microtask， 直接放进本队列末尾。
- 执行 UI render 操作，当前是否有渲染机会且需要渲染，如需要渲染执行各种渲染所需工作，包括执行 animation frame callbacks，最后渲染 UI，如不需要直接跳过。

补充：

⑴一个 eventloop 有一或多个 task 队列，是为了方便优先处理一些任务。

⑵是否有渲染机会

> 浏览上下文呈现机会是根据硬件限制（例如显示刷新率）和其他因素（例如页面性能或页面是否在后台）确定的。 渲染机会通常会定期出现。

如果浏览器尝试达到60Hz的刷新率，则渲染机每秒最多出现60次，约16.7毫秒出现一次。如果界面没有改变，浏览器也不会渲染。

⑶渲染需要的主要步骤Style calculation，Layout，Paint ，composite 上文中有介绍

### 2.3.2 结合图片

规范还有简述理解起来略微抽象，结合下图事件循坏的机制理解可能会清晰点

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8674efb8f4314d20a5282ac2d65d19f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

⑴检查macrotask队列是否为空

- 若不为空，执行macrotask中的一个任务，检查microtask队列是否为空
- 若为空，检查microtask队列是否为空

⑵检查microtask队列是否为空

- 若不为空，执行 microtask 队列中的所有 microtask， 直到队列为空。如果 microtask 中又添加了新的 microtask， 直接放进本队列末尾。等队列为空，检查是否需要渲染。
- 若为空，检查是否需要渲染

⑶检查是否需要渲染

- 需要渲染更新视图，检查macrotask队列是否为空
- 不需要渲染，检查macrotask队列是否为空

### 2.3.3 伪代码简单实现

```
while (eventLoop.waitForTask()) {
    const taskQueue = eventLoop.selectTaskQueue()
    if (taskQueue && taskQueue.hasTask()) {
        let currentTask = taskQueue.oldTask()
        execute(currentTask)
    }
    // 一个eventloop 只有一个 microtaskQueue
    const microtaskQueue = eventLoop.microTaskQueue
    while (microtaskQueue.hasMicrotask()) {
        microtaskQueue.processMicrotask()
    }

    if (shouldRender()) {
        // requestAnimationFrame() 回调执行时机
        runAnimationFrames()
        render()
    }
}
复制代码
```

### 2.3.4 小结

⑴ 一轮eventloop 由三个大步骤构成：执行一个 task，执行 microtask 队列， 可能会执行的ui render 阶段。

⑵ microtask 中注册的 microtask 事件会直接加入到当前 microtask 队列（只有一个微任务队列）。

⑶ requestAnimationFrame callback 在 render 阶段执行（浏览器在下次重绘之前调用指定的回调函数更新动画）。

# 3 event loop和渲染

这个小段讨论了我觉得可以加深理解和有意思的问题

## 3.1 强制同步布局（forced synchronous layout）

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e58220b5935487a8597257eb3b2a482~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)一般一帧到屏幕显示首先运行JavaScript，然后进行样式计算，然后进行布局，会按照上图顺序进行。

但是，强制浏览器更早地使用JavaScript进行布局，这称为强制同步布局。

以此段代码为例：

```
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        body {
            font-size: 16px
        }
        p {
            font-weight: bold
        }
        div {
            width: 100px;
            height: 100px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <p>Hello </p>
    <div id="box"></div>
    <button id="button">do it</button>
    <script>
        var button = document.getElementById('button');
        var box = document.getElementById('box');
        button.addEventListener('click', () => {
            for (var i = 0; i < 10; i++) {
                box.style.width = box.offsetWidth + 'px';
            }
        })
    </script>
</body>
</html>
复制代码
```

代码反复读取修改了box的宽度。因为修改了box的宽度，又读取了box的宽度，浏览器需要应用这个宽度，然后运行布局，方便读取此时box精确的宽度。

chrome-devtools performance工具 记录 点击按钮的分析截图 如下

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e8767944cce463ab03f69475269b079~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)可以看见反复进行了Style calculation，和Layout ，此时的流程如图。当前task 执行完后，等到渲染是界面才会进行像素管道整个流程。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/905ba5dc76524fcdb309588696c1f5ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

## 3.2 渲染时机

渲染完成后将渲染结果放入帧缓冲区，显示器以固定频率进行刷新通常是 60HZ，即每秒更新 60 张图片，也就是每16.66毫秒固定读取1次缓冲区中的图像，并将读取的图像显示到显示器上。并不是每一轮事件循环都会有渲染机会，以下文代码为例：

```
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        body {
            font-size: 50px
        }
        p {
            font-weight: bold
        }
        div {
            width: 400px;
            height: 400px;
            border: 10px solid #ccc;
        }
    </style>
</head>
<body>
    <div id='con'>this is con</div>
    <script>
        var con = document.getElementById('con');
        con.onclick = function() {
            setTimeout(function() {
                con.textContent = 0;
            }, 0)
            setTimeout(function() {
                con.textContent = 1;
            }, 0)
            setTimeout(function() {
                con.textContent = 2;
            }, 0)
            setTimeout(function() {
                con.textContent = 3;
            }, 0)
            setTimeout(function() {
                con.textContent = 4;
            }, 0)
            setTimeout(function() {
                con.textContent = 5;
            }, 0)
            setTimeout(function() {
                con.textContent = 6;
            }, 0)
        };
    </script>
</body>
</html
复制代码
```

chrome-devtools performance工具点击记录，点击方框，得到分析截图如下（运行得到结果不一，可以多运行几次观察思考），截取了两次运行的不同结果。第一次运行，界面出现0,1,6数字的渲染。第二次界面出现了0,4,6的数字渲染。（当然还有其他结果本文未截取）

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10e56616d124142af1e9ecb35db5d8f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)以图中显示结果0，4，6 的结果图进行分析。没有将数字都渲染显示出来，证明并不是每一轮事件循环都会有渲染机会。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d590f028c634d65a6d79a8335431b53~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

图中第二个UI render 前执行了 4个task（setTimeout 的 Function Call）。当前UI render 渲染的变化会在下一帧显示。所以0过后一帧显示的图像是4。

观察图像出现时间大概间隔16.6ms，屏幕渲染的时间间隔，当JavaScript 的task及它相关的所有microtask，执行时间较短时，浏览器会匹配设备的刷新率，并为每个屏幕刷新放置1张新图片或一帧，以实现平滑动画。

event loop 中当JavaScript 的task及它相关的所有microtask执行时间较长时就会影响下一帧造成卡顿。

# 4. 总结

文章整理三个问题：event loop处理模型，浏览器渲染流程，event loop和渲染。简述了宏任务，微任务，UI渲染时机，requestAnimationFram执行，记录了部分实践和自己的理解，理解不准确之处，还请教正。欢迎一起讨论学习。


作者：罗小二
链接：https://juejin.cn/post/6919160642293202951

# 五、事件循环进阶

# 六、极客时间

本节主要介绍渲染流程样式计算、布局、分层、绘制、合成及最终显示输出

- 样式计算：css文件主要来源于link引入，style插入，和行内style属性，渲染引擎解析到css时，要先将其转化为浏览器可以理解的styleSheet结构，转换过程需要经过属性值得标准化过程，和继承层叠规则计算出每个dom节点的样式，styleSheet也为之后js脚本提供操作接口
- 布局：布局阶段将dom树与样式表styleSheet进行合并计算出最终展示的节点的样式和内容
- 分层：当界面内元素出现层叠上下文属性时，并且出现了内容溢出，需要裁剪出现滚动条时，就会提升为独立的一层，用层来优化渲染合成图片的速度
- 绘制：当分层树生成后，渲染引擎会创建绘制列表，绘制的过程中需要使用合成线程来完成
- 分块：合成线程会将图层划分为图块，视口附近的图块会优先进行合成
- 栅格化：图块是栅格化的最小单位，将图块生成位图的操作称为栅格化，渲染进程维护了栅格化线程池，来完成图块到位图的转换，在栅格化过程中，还用到了GPU进程来加速位图的生成，使用GPU生成位图保存在GPU内存中，这个过程为快速栅格化的过程。
- 发出Draw Quad指令：所有图块被光栅化转化为位图后，合成线程会生成一个绘制图块的命令DrawQuad发送给浏览器进程。
- 输出显示：浏览器进程将图像发送给显卡的后缓冲区，后缓冲区和前缓冲区不断的交替使用，已到达显示器60HZ的速率刷出图像

<iframe src="../images/01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？.html" height="1000px"></iframe>
<iframe src="../images/02丨TCP协议：如何保证页面文件能被完整送达浏览器？.html" height="1000px"></iframe>
<iframe src="../images/03丨HTTP请求流程：为什么很多站点第二次打开速度会很快？.html" height="1000px"></iframe>
<iframe src="../images/04丨导航流程：从输入URL到页面展示，这中间发生了什么？.html" height="1000px"></iframe>
<iframe src="../images/05丨渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？.html" height="1000px"></iframe>
<iframe src="../images/06丨渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？ .html" height="1000px"></iframe>









